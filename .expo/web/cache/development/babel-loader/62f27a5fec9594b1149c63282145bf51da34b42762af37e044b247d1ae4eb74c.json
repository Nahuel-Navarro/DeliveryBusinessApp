{"ast":null,"code":"import * as Linking from \"expo-linking\";\nimport { resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nfunction assertIsReady(store) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\");\n  }\n}\nexport function push(url) {\n  return this.linkTo(resolveHref(url));\n}\nexport function replace(url) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\nexport function goBack() {\n  var _this$navigationRef, _this$navigationRef$c;\n  assertIsReady(this);\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : (_this$navigationRef$c = _this$navigationRef.current) == null ? void 0 : _this$navigationRef$c.goBack();\n}\nexport function canGoBack() {\n  var _this$navigationRef$c2, _this$navigationRef2, _this$navigationRef2$;\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return (_this$navigationRef$c2 = (_this$navigationRef2 = this.navigationRef) == null ? void 0 : (_this$navigationRef2$ = _this$navigationRef2.current) == null ? void 0 : _this$navigationRef2$.canGoBack()) != null ? _this$navigationRef$c2 : false;\n}\nexport function setParams() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.setParams.bind(_this$navigationRef3$))(params);\n}\nexport function linkTo(href, event) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n  if (href.startsWith(\".\")) {\n    var _this$linking$getPath, _this$linking$getPath2, _this$linking;\n    var base = (_this$linking$getPath = (_this$linking$getPath2 = (_this$linking = this.linking).getPathFromState) == null ? void 0 : _this$linking$getPath2.call(_this$linking, navigationRef.getRootState(), {\n      screens: [],\n      preserveGroups: true\n    })) != null ? _this$linking$getPath : \"\";\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state || state.routes.length === 0) {\n    console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n    return;\n  }\n  switch (event) {\n    case \"REPLACE\":\n      return navigationRef.dispatch(getNavigateReplaceAction(state, navigationRef.getRootState()));\n    default:\n      return navigationRef.dispatch(getNavigatePushAction(state));\n  }\n}\nfunction rewriteNavigationStateToParams(state) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!state) return params;\n  var lastRoute = state.routes.at(-1);\n  params.screen = lastRoute.name;\n  params.params = lastRoute.params ? JSON.parse(JSON.stringify(lastRoute.params)) : {};\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n  return JSON.parse(JSON.stringify(params));\n}\nfunction getNavigatePushAction(state) {\n  var _rewriteNavigationSta = rewriteNavigationStateToParams(state),\n    screen = _rewriteNavigationSta.screen,\n    params = _rewriteNavigationSta.params;\n  return {\n    type: \"NAVIGATE\",\n    payload: {\n      name: screen,\n      params: params\n    }\n  };\n}\nfunction getNavigateReplaceAction(previousState, parentState) {\n  var _lastNavigatorSupport;\n  var lastNavigatorSupportingReplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parentState;\n  var state = previousState.routes.at(-1);\n  if (parentState.type === \"stack\" || parentState.type === \"tab\") {\n    lastNavigatorSupportingReplace = parentState;\n  }\n  var currentRoute = parentState.routes.find(function (route) {\n    return route.name === state.name;\n  });\n  var routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n  if (state.state && routesAreEqual && currentRoute.state) {\n    return getNavigateReplaceAction(state.state, currentRoute.state, lastNavigatorSupportingReplace);\n  }\n  var _rewriteNavigationSta2 = rewriteNavigationStateToParams(previousState),\n    screen = _rewriteNavigationSta2.screen,\n    params = _rewriteNavigationSta2.params;\n  return {\n    type: lastNavigatorSupportingReplace.type === \"stack\" ? \"REPLACE\" : \"JUMP_TO\",\n    payload: {\n      name: screen,\n      params: params,\n      source: (_lastNavigatorSupport = lastNavigatorSupportingReplace) == null ? void 0 : _lastNavigatorSupport.key\n    }\n  };\n}","map":{"version":3,"names":["Linking","resolveHref","resolve","hasUrlProtocolPrefix","assertIsReady","store","navigationRef","isReady","Error","push","url","linkTo","replace","goBack","_this$navigationRef","_this$navigationRef$c","current","canGoBack","_this$navigationRef$c2","_this$navigationRef2","_this$navigationRef2$","setParams","_this$navigationRef3","_this$navigationRef3$","params","arguments","length","undefined","bind","href","event","openURL","linking","startsWith","_this$linking$getPath","_this$linking$getPath2","_this$linking","base","getPathFromState","call","getRootState","screens","preserveGroups","endsWith","state","getStateFromPath","config","routes","console","error","dispatch","getNavigateReplaceAction","getNavigatePushAction","rewriteNavigationStateToParams","lastRoute","at","screen","name","JSON","parse","stringify","_rewriteNavigationSta","type","payload","previousState","parentState","_lastNavigatorSupport","lastNavigatorSupportingReplace","currentRoute","find","route","routesAreEqual","index","_rewriteNavigationSta2","source","key"],"sources":["C:/Users/Multisoft/Desktop/MobileApp/appMobilePedidos/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import {\n  type NavigationAction,\n  type NavigationState,\n} from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\n\nimport { ResultState } from \"../fork/getStateFromPath\";\nimport { Href, resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nimport type { RouterStore } from \"./router-store\";\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      \"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\"\n    );\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number> = {}\n) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n\n  if (href.startsWith(\".\")) {\n    let base =\n      this.linking.getPathFromState?.(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true,\n      }) ?? \"\";\n\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error(\n      \"Could not generate a valid navigation state for the given path: \" + href\n    );\n    return;\n  }\n\n  switch (event) {\n    case \"REPLACE\":\n      return navigationRef.dispatch(\n        getNavigateReplaceAction(state, navigationRef.getRootState())\n      );\n    default:\n      return navigationRef.dispatch(getNavigatePushAction(state));\n  }\n}\n\ntype NavigationParams = Partial<{\n  screen: string;\n  params: NavigationParams;\n}>;\n\nfunction rewriteNavigationStateToParams(\n  state?: { routes: ResultState[\"routes\"] },\n  params: NavigationParams = {}\n) {\n  if (!state) return params;\n  // We Should always have at least one route in the state\n  const lastRoute = state.routes.at(-1)!;\n  params.screen = lastRoute.name;\n  // Weirdly, this always needs to be an object. If it's undefined, it won't work.\n  params.params = lastRoute.params\n    ? JSON.parse(JSON.stringify(lastRoute.params))\n    : {};\n\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n\n  return JSON.parse(JSON.stringify(params));\n}\n\nfunction getNavigatePushAction(state: ResultState) {\n  const { screen, params } = rewriteNavigationStateToParams(state);\n  return {\n    type: \"NAVIGATE\",\n    payload: {\n      name: screen,\n      params,\n    },\n  };\n}\n\nfunction getNavigateReplaceAction(\n  previousState: ResultState,\n  parentState: NavigationState,\n  lastNavigatorSupportingReplace: NavigationState = parentState\n): NavigationAction {\n  // We should always have at least one route in the state\n  const state = previousState.routes.at(-1)!;\n\n  // Only these navigators support replace\n  if (parentState.type === \"stack\" || parentState.type === \"tab\") {\n    lastNavigatorSupportingReplace = parentState;\n  }\n\n  const currentRoute = parentState.routes.find(\n    (route) => route.name === state.name\n  );\n  const routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n\n  // If there is nested state and the routes are equal, we should keep going down the tree\n  if (state.state && routesAreEqual && currentRoute.state) {\n    return getNavigateReplaceAction(\n      state.state,\n      currentRoute.state as any,\n      lastNavigatorSupportingReplace\n    );\n  }\n\n  // Either we reached the bottom of the state or the point where the routes diverged\n  const { screen, params } = rewriteNavigationStateToParams(previousState);\n  return {\n    type:\n      lastNavigatorSupportingReplace.type === \"stack\" ? \"REPLACE\" : \"JUMP_TO\",\n    payload: {\n      name: screen,\n      params,\n      // Ensure that the last navigator supporting replace is the one that handles the action\n      source: lastNavigatorSupportingReplace?.key,\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}